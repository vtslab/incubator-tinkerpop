////
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
////

// @author Daniel Kuppitz (anwer on gremlin user list)
// @author Robert Dale (answer on gremlin user list)
// @author Marc de Lignie

[[connected-components]]
== Weakly Connected Components

TinkerPop can be used to find link:https://en.wikipedia.org/wiki/Directed_graph#Directed_graph_connectivity[connected
components] in a graph. In a directed graph like in TinkerPop, components can be weakly or strongly connected.
This recipe is restricted to finding weakly connected components, in which the direction of edges is not taken into
account.

Depending on the size of the graph, three solution regimes can be discriminated:

1. Small graphs that fit in the memory of a single machine

2. Medium graphs backed by storage for which a linear scan is still feasible. This regimes is left to third party
TinkerPop implmentations, since TinkerPop itself has no storage-backed reference implementations. The idea is that
component membership is stored in the graph, rather than in memory.

3. Large graphs requiring an OLAP approach to yields results in a reasonable time.


These regimes are discussed separately using the following graph with three weakly connected components:

image:connected-components.png[width=600]

[gremlin-groovy]
----
g.addV().property(id, "A").as("a").
  addV().property(id, "B").as("b").
  addV().property(id, "C").as("c").
  addV().property(id, "D").as("d").
  addV().property(id, "E").as("e").
  addV().property(id, "F").
  addE("link").from("a").to("b").
  addE("link").from("b").to("c").
  addE("link").from("d").to("e").iterate()
----


===== Small graphs

This situation can be handled with an OLTP traversal on the `TinkerGraph`. A straightforward way to detect the
various subgraphs is to do this:

[gremlin-groovy,existing]
----
g.V().emit(cyclicPath().or().not(both())).                                    <1>
    repeat(__.where(without('a')).store('a').both()).until(cyclicPath()).     <2>
    group().by(path().unfold().limit(1)).                                     <3>
    by(path().unfold().dedup().fold()).                                       <4>
    select(values).unfold()                                                   <5>
----

<1> The initial emit() step allows for output of isolated vertices, in addition to the discovery of
components as described in (2).

<2> The entire component to which the first returned vertex belongs, is visited. To allow for components of any
structure, a repeat loop is applied that only stops for a particular branch of the component when it detects a cyclic
path.  Collection `'a'` is used to keep track of visited vertices, for both subtraversals within a component
and new traversals resulting from the `g.V()` linear scan.

<3> While `'a'` nicely keeps track of vertices already visited, the actual components need to be extracted from the
path information of surviving traversers. The `path().unfold().limit(1)` closure provides the starting vertex
of surviving traversers, which can be used to group the components.

<4> This clause collects the unique vertices from all paths with the same starting vertex, thus from the same
weak component.

<5> The values of the groupby map contain the lists of vertices making up the requested components.

This algorithm completes in linear time with the number of vertices and edges, because a traversal is started for each
vertex and each edge with its associated out-vertex is visited exactly once.


==== Large graphs

Large graphs require an OLAP solution with a custom VertexProgram that can be run using a graph implementation's
GraphComputer, in particular `SparkGraphComputer` on a `HadoopGraph`. The OLAP solution also runs faster for most
medium-sized graphs, that is when these graph have a 'natural' structure with a limited maximum path length.

The TinkerPop library of vertex programs contains the `WeakComponentsVertexProgram` which can be run in the same
way as the link:http://tinkerpop.apache.org/docs/x.y.z/reference/#peerpressurevertexprogram[PeerPressureVertexProgram]:

[gremlin-groovy,existing]
----
result = g.getGraph().compute().
    program(WeakComponentsVertexProgram.build().maxIterations(100).create()).
    mapReduce(ClusterPopulationMapReduce.build().create()).
    mapReduce(ClusterCountMapReduce.build().create()).
    submit().get()
result.memory().clusterPopulation
gResult = result.graph().traversal()
gResult.V().valueMap(true)
----

The vertex program has interconnected vertices exchange id's and store the lowest id until no vertex receives a
lower id. This algorithm is commonly applied in
link:https://en.wikipedia.org/wiki/Bulk_synchronous_parallel[bulk synchronous parallel] systems, e.g. in
link:https://spark.apache.org/graphx[Apache Spark GraphX].

==== Scalability

ToDo:
 - limits and run time regime 1
 - test of friendster graph regime 3
 - discuss: link:http://www.vldb.org/pvldb/vol7/p1821-yan.pdf[http://www.vldb.org/pvldb/vol7/p1821-yan.pdf]